\documentclass[10pt]{article}
\usepackage{amsmath}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{parskip}
\renewcommand{\baselinestretch}{1.05} 
\usepackage{enumitem}

\usepackage{enumitem}


\usepackage{hyperref}

\begin{document}
\setlist{ itemsep=-1.6pt }
{
\vspace{-1ex}
\centering
AME 50551: Introduction to Robotics\\[1ex]
{\large Project 1: Numerical Inverse Kinematics\\[.5ex] and the {\sc Matlab} Robotics Systems Toolbox}\\[1ex]
Upload your project report PDF and MATLAB code to Sakai by Wednesday, Oct.~24th, 11:55 PM\\
}

\hrulefill\\[-1ex]
{\small

{\bf Objective:} After completing the project you should be able to:
\vspace{-10px}
\begin{enumerate}[label=(\alph*)]
\item Code a backtracking line-search to select step sizes in iterative numerical IK.
\item Solve IK problems numerically using iterative approaches.
\item Approximately solve IK problems when the desired end-effector pose is not in the workspace of the manipulator.
\end{enumerate}
\vspace{-10px}
}

\hrulefill\\[-3ex]

This project requires the Robotics Systems Toolbox in {\sc Matlab} R2017b. If you do not have this version (or later) on your computer, you should install it (and the Toolbox) before getting started. You may work in pairs for this project. Each project team should hand in a report that includes deliverables specified in this document. In addition to the listed deliverables,  {\bf include a copy of your \underline{final code}}.


{\bf Part 1:} (IK for a Single Target Pose)

\begin{itemize}
\item Download the Project 1 starter code from Sakai.
\item Run the starter code. You should see a visualization like the one shown below.

\vspace{5px}
{\hfill \includegraphics[height = 1.9in]{Initial.png} \hfill }
\vspace{5px}

\item Uncomment the function {\tt computeError}. Read the documentation to understand the inputs and outputs. After reading, fill in the blanks as identified by {\tt ???} in the code. The goal of this function is to compute a $6 \times 1$ vector for the error between the desired end-effector pose (position and orientation) and the actual end-effector pose. The error vector should be formed as follows: the $3\times 1$ angle-axis orientation error goes on top, and the $3 \times 1$ position error goes on the bottom. All quantities should be expressed with respect to the base frame.

\item Next, uncomment the function {\tt IK\_step}. Again, read the documentation for the function and the fill in the blanks. The goal of this function is to update the joint angles so that the gripper pose approaches the desired pose. The magnitude of the error should decrease from this update operation.

\item Finally uncomment the function {\tt IK}. Again, read the documentation and fill in the blanks. Once you are done, run
{\tt [theta, iteration\_errors] = IK(T\_desired, theta\_0, lbr, gripper, 1);} If all goes correctly, the manipulator should iterate toward the goal and converge in 10-20 iterations.

\end{itemize}
{\em Deliverables:}
\begin{enumerate}
\item A plot of the error norm versus iteration number for your iterative numerical IK solution. (10 points)
\item A screenshot showing the manipulator in the solution pose from iterative IK. (10 points)
\item Code (35 points)
\end{enumerate}

\pagebreak
{\bf Part 2:} (IK for a Target Trajectory)

\begin{itemize}

\item  Consider a modified IK problem with the same desired orientation as before, but with a desired position along the edge of the cup. 
\begin{verbatim}
p_desired = cupPosition + [-cupRadius*cos(polar_angle_for_cup), ...
                           -cupRadius*sin(polar_angle_for_cup), ...
                           .2];
\end{verbatim}

\item Write a {\tt for} loop that solves the IK problem for 100 evenly spaced values of {\tt polar\_angle\_for\_cup} in the interval $[0,2 \pi]$. As you move around the circle, use each solution as an initial guess for the next. Use the command {\tt show(lbr, theta , 'PreservePlot', false); drawnow; pause(0.05);} to show the robot in the solution configuration after each solution.

\end{itemize}

\vspace{10px}

{\em Deliverables:}
\begin{enumerate}
\item A plot of IK solution joint angles versus {\tt polar\_angle\_for\_cup}. All joint angles should be reported on the interval $[-\pi, \pi]$. ({\em Hint: use} {\tt wrapToPi}.) (10 points)
\item How does the performance change if you use the same initial condition for all IK solves? What is the effect on the joint angle trajectories and the overall time it takes to solve the IK problems? Provide an explanation for your findings. (5 points)
\item Code (10 points)
\end{enumerate}


\vspace{20px}
{\bf Part 3:} (Approximate IK for Poses Beyond the Workspace)

\begin{itemize}
\item Modify the radius of the cup to {\tt cupRadius = 0.35;}. With this parameter setting, the far edge of your previous trajectory should no longer be within the workspace of the manipulator.
\item Re-run your code from Part 2. Describe what problem arises.
\item Propose a modification to your IK routine that allows the manipulator to solve the IK problem as closely as possible for poses beyond the workspace. For the purposes of this project, you can consider the IK problem solved as closely as possible if the {\tt IK\_step} function fails to reduce the error by more than $10^{-6}$. 
\end{itemize}


{\em Deliverables:}
\begin{enumerate}
\item Answer: What problem originally occurs when the desired pose is beyond the workspace? (5 points)
\item A plot of solution joint angles versus {\tt polar\_angle\_for\_cup} with parameters {\tt cupRadius = 0.35;} and {\tt cupPosition = [0.5, -0.5, .1];}. Joint angles should be reported on the interval $[-\pi, \pi]$. (5 points)
\item A parametric plot of the $x$ and $y$ positions of the end effector along the solution trajectory. (5 points)
\item Code (5 points)
\end{enumerate}




%
%\item To check if your answer is correct, execute the following code
%
%\begin{verbatim}
%e = computeError(T_desired, theta_0, lbr, gripper);
%T = getTransform(lbr,theta_0, gripper);
%check1 = expm([ 0 -e(3) e(2); e(3) 0 -e(1) ; -e(2) e(1) 0]) * T(1:3,1:3) ...
%          - T_desired(1:3,1:3)
%check2 = e(4:6) + T(1:3,4) - T_desired(1:3,4)
%\end{verbatim}
%
%If both {\tt check1} and {\tt check2} are all zeros, then 

















\end{document}


\end{document}